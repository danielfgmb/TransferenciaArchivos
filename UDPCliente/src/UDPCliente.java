import java.net.*;
import java.io.*;
import java.nio.ByteBuffer;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Year;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Scanner;


public class UDPCliente extends Thread {

    public static final int TAMANO_PAQUETE = 512;

    private byte[] contenido = new byte[TAMANO_PAQUETE+4];

    private int numeroByte;

    public int paquetesEsperados;

    public int paq;

    public int paqRecibidos;

    public int paqPerdidos;

    public double progreso;

    public int idCliente;

    public static String hostname;

    public int puertoServidorConexion = 0;

    public static int puertoServidor;

    public static int cantidadClientes;

    public static int timeout = 5000;

    public String estado = "Solicitud";

    public long tiempoFinal=0;

    public long startTime=0;

    public static String logFile="";

    public static void main(String[] args) throws Exception {    
        inicio();
        //inicio_rapido();
        new Monitor().start();
        // se inicia la cantidad del clientes deseada
        for(int i=0; i<cantidadClientes; i++){
            UDPCliente cliente = new UDPCliente(i+1);
            Monitor.asignarCliente(cliente);
            cliente.start();
        }
    }

    public UDPCliente(int id){
        this.idCliente = id;
    }

    @Override
    public void run(){

        //inicio();
        // establece el host y el puerto
        

        // contador de paquetes realmente recibidos
        int i = 0;

        // variable para indicar si termino
        boolean termino=false;

        startTime = System.currentTimeMillis();

        try {
            log(this,"Inicia el Thread para conexion con el servidor del Cliente "+idCliente);
            
            // saca la dirección del host
            InetAddress direccion = InetAddress.getByName(hostname);

            // abre el datagram socket
            DatagramSocket socket = new DatagramSocket();
            log(this,"Cliente "+idCliente+" con direccion IP "+socket.getLocalSocketAddress());
            
            // establece el timeout
            socket.setSoTimeout(timeout);

            // se envía la solicitud de conexion
            DatagramPacket request = new DatagramPacket(new byte[1], 1, direccion, puertoServidor);
            socket.send(request);
            log(this,"Conexion con "+hostname+" desde el puerto "+socket.getLocalPort()+" timeout de "+timeout);
            log(this,"Solicitud al servidor ("+hostname+":"+puertoServidor+") enviada");
            // se reciben paquetes hasta que finalice el archivo de acuerdo con el numero de paquetes esperados
            while (!termino) {
                // tamaño de paquete que debe recibir + 4 bytes del número de paquete
                byte[] buffer = new byte[TAMANO_PAQUETE+4];
                // 4 bytes del numero de paquete
                byte[] numeroPaquete = new byte[4];

                // recibe el paquete desde el socket
                DatagramPacket response = new DatagramPacket(buffer, buffer.length);
                socket.receive(response);

                // se extraen los primero 4 bytes para identificar el número de paquete inverso
                numeroPaquete[0] = buffer[0];
                numeroPaquete[1] = buffer[1];
                numeroPaquete[2] = buffer[2];
                numeroPaquete[3] = buffer[3];

                paq = ByteBuffer.wrap(numeroPaquete).getInt();

                if(i==0){
                    
                    puertoServidorConexion = response.getPort();
                    // conociendo el tamaño del paquete, y como el primer paquete es el numero de paquetes total
                    contenido = new byte[TAMANO_PAQUETE*paq];
                    numeroByte = 0;
                    // mas 1 porque se entrega ya restándole el paquete que se envió
                    paquetesEsperados = paq+1;

                    estado="Transferencia";
                    log(this,"Primer paquete recibido, puerto de servidor para envio "+puertoServidorConexion+" paquetes esperados "+paquetesEsperados);
                    
                }

                

                // si el numero de paquete es 0 quiere decir que es el ultimo
                if(paq==0){
                    termino=true;
                }

                // pasando cada paquete a un solo array de bytes con el contenido
                for(int nByte=4; nByte<buffer.length && numeroByte<contenido.length; nByte++){
                    contenido[numeroByte]=buffer[nByte];
                    numeroByte+=1;
                }

                // se sincrementa el numero de paquetes recibidos
                i+=1;
                paqRecibidos=i;
                // como paq es el inverso
                paqPerdidos = (paquetesEsperados - paq ) - (paqRecibidos);
                progreso = ((double) paquetesEsperados - paq ) / paquetesEsperados;
            }

            estado="Termino";
            log(this,"Transferencia con servidor completada, paquetes perdidos "+paqPerdidos);
            
            

            socket.close();
 
        } catch (SocketTimeoutException ex) {
            
            estado="Timeout";
            log(this,"TIMEOUT. Transferencia con servidor incompleta, paquetes perdidos "+paqPerdidos+", progreso: "+progreso);
            
        } catch (IOException ex) {
            estado="Error";
            log(this,"ERROR JAVA. Transferencia con servidor incompleta, paquetes perdidos "+paqPerdidos+", progreso: "+progreso);
            log(this,ex.getMessage());
        }
       
        tiempoFinal = System.currentTimeMillis() - startTime;
        log(this,"Tiempo total transcurrido: "+tiempoFinal+"ms");
        long segundoTranscurridos = tiempoFinal/1000;
        double megaBytesEnviados = 0;
        if(paqRecibidos>0){
            megaBytesEnviados = ((paqRecibidos*TAMANO_PAQUETE*1.0)/1024)/segundoTranscurridos;
        }
        log(this,"Tasa de transferencia final: "+megaBytesEnviados+"kB/s");

        if(paqPerdidos == 0 && paquetesEsperados>0){
            log(this,"ENVIO EXITOSO");
        }
        else{
            log(this,"ENVIO FALLIDO por PAQUETES FALTANTES");
        }


        try {
            try{
                Files.createDirectories(Paths.get("ArchivosRecibidos/"));
            }
            catch(Exception e){
                // directorio ya existia
            }
            
            FileOutputStream fos = new FileOutputStream("ArchivosRecibidos/Cliente"+idCliente+"-Prueba"+cantidadClientes+".txt");

            fos.write(contenido);
            fos.close();
            log(this,"Archivo escrito exitosamente en ArchivosRecibidos/Cliente"+idCliente+"-Prueba"+cantidadClientes+".txt");

        } catch (IOException e) {
            log(this,"Error en escritura ArchivosRecibidos/Cliente"+idCliente+"-Prueba"+cantidadClientes+".txt");
            log(this,e.getMessage());
        }
    }

    public static void log(UDPCliente cliente, String log){
        int year = Year.now().getValue();
        Date date = new Date();   
        Calendar calendar = GregorianCalendar.getInstance();
        calendar.setTime(date); 
        int day = calendar.get(Calendar.DAY_OF_MONTH);
        int second = calendar.get(Calendar.SECOND);
        int minute = calendar.get(Calendar.MINUTE);
        int hour = calendar.get(Calendar.HOUR_OF_DAY);       
        int month =calendar.get(Calendar.MONTH)+1;  
        int milisecond = calendar.get(Calendar.MILLISECOND);
        String prefix = year+"-"+month+"-"+day+"-"+hour+"-"+minute+"-"+second+"-"+milisecond;

        if(logFile.equals("")){
            try {
                try{
                    Files.createDirectories(Paths.get("Logs/"));
                }
                catch(Exception e){
                    // si el directorio ya esta creado
                    
                }
                
                logFile = "Logs/"+prefix+"-log.txt"; 
                File file = new File(logFile);
                file.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        try {
            BufferedWriter output = new BufferedWriter(new FileWriter(logFile, true));
            output.newLine();
            output.write("["+prefix+"]:(Cliente "+cliente.idCliente+") "+log);
            output.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    /* METODOS PARA IMPRESION */

    public static String formatDiv(String str)
    {
        return str.replace('a', '\u250c')
                .replace('b', '\u252c')
                .replace('c', '\u2510')
                .replace('d', '\u251c')
                .replace('e', '\u253c')
                .replace('f', '\u2524')
                .replace('g', '\u2514')
                .replace('h', '\u2534')
                .replace('i', '\u2518')
                .replace('-', '\u2500');
    }

    public static void inicio_rapido(){
        hostname = "localhost";
        puertoServidor = 6000;
        cantidadClientes = 3;
        timeout = 6000;
        Monitor.modoCompatibilidad=true;
    }

    public long tiempoTotal(){
        if(estado.equals("Transferencia")||estado.equals("Solicitud")){
            return System.currentTimeMillis() - startTime;
        }
        return tiempoFinal;
    }

    public static void inicio(){
        String header = "\n";
        header += formatDiv("a----------------------------------------------------------------c\n");
        header += formatRow("|                        LABORATORIO 3                           |\n");
        header += formatRow("|              Implementación de Servidores TCP y UDP            |\n");
        header += formatRow("|                     Profesor: Yezid Donoso                     |\n");
        header += formatRow("|                 Asistente Graduado: Nicolás Segura             |\n");
        header += formatDiv("d----------------------------------------------------------------f\n");
        header += formatRow("|                          CLIENTE UDP                           |\n");
        header += formatDiv("d--------------------------------b-------------------------------f\n");
        header += formatRow("|           GRUPO 1              |           SECCION 5           |\n");
        header += formatDiv("g--------------------------------h-------------------------------i\n");     
        System.out.println(header);

        String datos = "";
        datos += formatDiv("a----------------------------------------------------------------c\n");
        datos += formatRow("| INGRESE LOS PARÁMETROS DE CONFIGURACION                        |\n");
        datos += formatDiv("d----------------------------------------------------------------f\n");
        System.out.print(datos);

        
        System.out.print(formatRow("| Puerto Servidor:  "));
        Scanner sc = new Scanner(System.in);
        puertoServidor = Integer.parseInt(sc.nextLine());
        
        System.out.print(formatDiv("d----------------------------------------------------------------f\n"));

        System.out.print(formatRow("| Hostname (IP): "));
        hostname=sc.nextLine();

        System.out.print(formatDiv("d----------------------------------------------------------------f\n"));

        System.out.print(formatRow("| Numero clientes: "));
        cantidadClientes=Integer.parseInt(sc.nextLine());

        System.out.print(formatDiv("d----------------------------------------------------------------f\n"));

        System.out.print(formatRow("| Timeout: "));
        timeout=Integer.parseInt(sc.nextLine());

        System.out.print(formatDiv("d----------------------------------------------------------------f\n"));

        System.out.print(formatRow("|                   Modo compatibilidad mensajes                 |\n"));
        System.out.print(formatRow("|        (activar cuando los progresos no se ven correctamente)  |\n"));
        System.out.print(formatDiv("d----------------------------------------------------------------f\n"));
        System.out.print(formatRow("| (S/N): "));
        String compat = sc.nextLine();
        if(compat.equals("S")){
            Monitor.modoCompatibilidad=true;
        }
        System.out.print(formatDiv("g----------------------------------------------------------------i\n\n")); 
        
        sc.close();

    }

    public static String formatRow(String str)
    {
        return str.replace('|', '\u2502');
    }

    public static String formatProgress(String str)
    {
        return str.replace('|', '\u2502')
               .replace('-', '\u2588');
    }

}
